{
  "abs": {
    "args": [
      {
        "name": "x",
        "type": "number"
      }
    ],
    "result": {
      "description": "the absolute value of `x`",
      "name": "y",
      "type": "number"
    }
  },
  "all": {
    "args": [
      {
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "result": {
      "type": "boolean"
    }
  },
  "and": {
    "args": [
      {
        "name": "x",
        "type": "set[any]"
      },
      {
        "name": "y",
        "type": "set[any]"
      }
    ],
    "result": {
      "description": "the intersection of `x` and `y`",
      "name": "z",
      "type": "set[any]"
    }
  },
  "any": {
    "args": [
      {
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "result": {
      "type": "boolean"
    }
  },
  "array.concat": {
    "args": [
      {
        "name": "x",
        "type": "array[any]"
      },
      {
        "name": "y",
        "type": "array[any]"
      }
    ],
    "result": {
      "description": "the concatenation of `x` and `y`",
      "name": "z",
      "type": "array[any]"
    }
  },
  "array.reverse": {
    "args": [
      {
        "description": "the array to be reversed",
        "name": "arr",
        "type": "array[any]"
      }
    ],
    "result": {
      "description": "an array containing the elements of `arr` in reverse order",
      "name": "rev",
      "type": "array[any]"
    }
  },
  "array.slice": {
    "args": [
      {
        "description": "the array to be sliced",
        "name": "arr",
        "type": "array[any]"
      },
      {
        "description": "the start index of the returned slice; if less than zero, it's clamped to 0",
        "name": "start",
        "type": "number"
      },
      {
        "description": "the stop index of the returned slice; if larger than `count(arr)`, it's clamped to `count(arr)`",
        "name": "stop",
        "type": "number"
      }
    ],
    "result": {
      "description": "the subslice of `array`, from `start` to `end`, including `arr[start]`, but excluding `arr[end]`",
      "name": "slice",
      "type": "array[any]"
    }
  },
  "assign": {
    "args": [
      {
        "type": "any"
      },
      {
        "type": "any"
      }
    ],
    "result": {
      "type": "boolean"
    }
  },
  "base64.decode": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "base64 deserialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "base64.encode": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "base64 serialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "base64.is_valid": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if `x` is valid base64 encoded value, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "base64url.decode": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "base64url deserialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "base64url.encode": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "base64url serialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "base64url.encode_no_pad": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "base64url serialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "bits.and": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      }
    ],
    "result": {
      "name": "z",
      "type": "number"
    }
  },
  "bits.lsh": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "s",
        "type": "number"
      }
    ],
    "result": {
      "name": "z",
      "type": "number"
    }
  },
  "bits.negate": {
    "args": [
      {
        "name": "x",
        "type": "number"
      }
    ],
    "result": {
      "name": "z",
      "type": "number"
    }
  },
  "bits.or": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      }
    ],
    "result": {
      "name": "z",
      "type": "number"
    }
  },
  "bits.rsh": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "s",
        "type": "number"
      }
    ],
    "result": {
      "name": "z",
      "type": "number"
    }
  },
  "bits.xor": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      }
    ],
    "result": {
      "name": "z",
      "type": "number"
    }
  },
  "cast_array": {
    "args": [
      {
        "type": "any"
      }
    ],
    "result": {
      "type": "array[any]"
    }
  },
  "cast_boolean": {
    "args": [
      {
        "type": "any"
      }
    ],
    "result": {
      "type": "boolean"
    }
  },
  "cast_null": {
    "args": [
      {
        "type": "any"
      }
    ],
    "result": {
      "type": "null"
    }
  },
  "cast_object": {
    "args": [
      {
        "type": "any"
      }
    ],
    "result": {
      "type": "object[any: any]"
    }
  },
  "cast_set": {
    "args": [
      {
        "type": "any"
      }
    ],
    "result": {
      "type": "set[any]"
    }
  },
  "cast_string": {
    "args": [
      {
        "type": "any"
      }
    ],
    "result": {
      "type": "string"
    }
  },
  "ceil": {
    "args": [
      {
        "description": "the number to round",
        "name": "x",
        "type": "number"
      }
    ],
    "result": {
      "description": "the result of rounding `x` _up_",
      "name": "y",
      "type": "number"
    }
  },
  "concat": {
    "args": [
      {
        "name": "delimiter",
        "type": "string"
      },
      {
        "description": "strings to join",
        "name": "collection",
        "type": "any\u003carray[string], set[string]\u003e"
      }
    ],
    "result": {
      "name": "output",
      "type": "string"
    }
  },
  "contains": {
    "args": [
      {
        "description": "string to search in",
        "name": "haystack",
        "type": "string"
      },
      {
        "description": "substring to look for",
        "name": "needle",
        "type": "string"
      }
    ],
    "result": {
      "description": "result of the containment check",
      "name": "result",
      "type": "boolean"
    }
  },
  "count": {
    "args": [
      {
        "description": "the set/array/object/string to be counted",
        "name": "collection",
        "type": "any\u003cstring, array[any], object[any: any], set[any]\u003e"
      }
    ],
    "result": {
      "description": "the count of elements, key/val pairs, or characters, respectively.",
      "name": "n",
      "type": "number"
    }
  },
  "crypto.hmac.equal": {
    "args": [
      {
        "description": "mac1 to compare",
        "name": "mac1",
        "type": "string"
      },
      {
        "description": "mac2 to compare",
        "name": "mac2",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the MACs are equals, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "crypto.hmac.md5": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      },
      {
        "description": "key to use",
        "name": "key",
        "type": "string"
      }
    ],
    "result": {
      "description": "MD5-HMAC of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.hmac.sha1": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      },
      {
        "description": "key to use",
        "name": "key",
        "type": "string"
      }
    ],
    "result": {
      "description": "SHA1-HMAC of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.hmac.sha256": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      },
      {
        "description": "key to use",
        "name": "key",
        "type": "string"
      }
    ],
    "result": {
      "description": "SHA256-HMAC of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.hmac.sha512": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      },
      {
        "description": "key to use",
        "name": "key",
        "type": "string"
      }
    ],
    "result": {
      "description": "SHA512-HMAC of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.md5": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "MD5-hash of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.sha1": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "SHA1-hash of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.sha256": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "SHA256-hash of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.x509.parse_and_verify_certificates": {
    "args": [
      {
        "description": "base64 encoded DER or PEM data containing two or more certificates where the first is a root CA, the last is a leaf certificate, and all others are intermediate CAs",
        "name": "certs",
        "type": "string"
      }
    ],
    "result": {
      "description": "array of `[valid, certs]`: if the input certificate chain could be verified then `valid` is `true` and `certs` is an array of X.509 certificates represented as objects; if the input certificate chain could not be verified then `valid` is `false` and `certs` is `[]`",
      "name": "output",
      "type": "array\u003cboolean, array[object[string: any]]\u003e"
    }
  },
  "crypto.x509.parse_certificate_request": {
    "args": [
      {
        "description": "base64 string containing either a PEM encoded or DER CSR or a string containing a PEM CSR",
        "name": "csr",
        "type": "string"
      }
    ],
    "result": {
      "description": "X.509 CSR represented as an object",
      "name": "output",
      "type": "object[string: any]"
    }
  },
  "crypto.x509.parse_certificates": {
    "args": [
      {
        "description": "base64 encoded DER or PEM data containing one or more certificates or a PEM string of one or more certificates",
        "name": "certs",
        "type": "string"
      }
    ],
    "result": {
      "description": "parsed X.509 certificates represented as objects",
      "name": "output",
      "type": "array[object[string: any]]"
    }
  },
  "crypto.x509.parse_keypair": {
    "args": [
      {
        "description": "string containing PEM or base64 encoded DER certificates",
        "name": "cert",
        "type": "string"
      },
      {
        "description": "string containing PEM or base64 encoded DER keys",
        "name": "pem",
        "type": "string"
      }
    ],
    "result": {
      "description": "if key pair is valid, returns the tls.certificate(https://pkg.go.dev/crypto/tls#Certificate) as an object. If the key pair is invalid, nil and an error are returned.",
      "name": "output",
      "type": "object[string: any]"
    }
  },
  "crypto.x509.parse_rsa_private_key": {
    "args": [
      {
        "description": "base64 string containing a PEM encoded RSA private key",
        "name": "pem",
        "type": "string"
      }
    ],
    "result": {
      "description": "JWK as an object",
      "name": "output",
      "type": "object[string: any]"
    }
  },
  "div": {
    "args": [
      {
        "description": "the dividend",
        "name": "x",
        "type": "number"
      },
      {
        "description": "the divisor",
        "name": "y",
        "type": "number"
      }
    ],
    "result": {
      "description": "the result of `x` divided by `y`",
      "name": "z",
      "type": "number"
    }
  },
  "endswith": {
    "args": [
      {
        "description": "search string",
        "name": "search",
        "type": "string"
      },
      {
        "description": "base string",
        "name": "base",
        "type": "string"
      }
    ],
    "result": {
      "description": "result of the suffix check",
      "name": "result",
      "type": "boolean"
    }
  },
  "eq": {
    "args": [
      {
        "type": "any"
      },
      {
        "type": "any"
      }
    ],
    "result": {
      "type": "boolean"
    }
  },
  "equal": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "result": {
      "description": "true if `x` is equal to `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "floor": {
    "args": [
      {
        "description": "the number to round",
        "name": "x",
        "type": "number"
      }
    ],
    "result": {
      "description": "the result of rounding `x` _down_",
      "name": "y",
      "type": "number"
    }
  },
  "format_int": {
    "args": [
      {
        "description": "number to format",
        "name": "number",
        "type": "number"
      },
      {
        "description": "base of number representation to use",
        "name": "base",
        "type": "number"
      }
    ],
    "result": {
      "description": "formatted number",
      "name": "output",
      "type": "string"
    }
  },
  "glob.match": {
    "args": [
      {
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "glob pattern delimiters, e.g. `[\".\", \":\"]`, defaults to `[\".\"]` if unset. If `delimiters` is `null`, glob match without delimiter.",
        "name": "delimiters",
        "type": "any\u003cnull, array[string]\u003e"
      },
      {
        "name": "match",
        "type": "string"
      }
    ],
    "result": {
      "description": "true if `match` can be found in `pattern` which is separated by `delimiters`",
      "name": "result",
      "type": "boolean"
    }
  },
  "glob.quote_meta": {
    "args": [
      {
        "name": "pattern",
        "type": "string"
      }
    ],
    "result": {
      "description": "the escaped string of `pattern`",
      "name": "output",
      "type": "string"
    }
  },
  "graph.reachable": {
    "args": [
      {
        "description": "object containing a set or array of neighboring vertices",
        "name": "graph",
        "type": "object[any: any\u003carray[any], set[any]\u003e]"
      },
      {
        "description": "set or array of root vertices",
        "name": "initial",
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "result": {
      "description": "set of vertices reachable from the `initial` vertices in the directed `graph`",
      "name": "output",
      "type": "set[any]"
    }
  },
  "graph.reachable_paths": {
    "args": [
      {
        "description": "object containing a set or array of root vertices",
        "name": "graph",
        "type": "object[any: any\u003carray[any], set[any]\u003e]"
      },
      {
        "description": "initial paths",
        "name": "initial",
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "result": {
      "description": "paths reachable from the `initial` vertices in the directed `graph`",
      "name": "output",
      "type": "set[array[any]]"
    }
  },
  "graphql.is_valid": {
    "args": [
      {
        "name": "query",
        "type": "any\u003cstring, object[any: any]\u003e"
      },
      {
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "result": {
      "description": "`true` if the query is valid under the given schema. `false` otherwise.",
      "name": "output",
      "type": "boolean"
    }
  },
  "graphql.parse": {
    "args": [
      {
        "name": "query",
        "type": "any\u003cstring, object[any: any]\u003e"
      },
      {
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "result": {
      "description": "`output` is of the form `[query_ast, schema_ast]`. If the GraphQL query is valid given the provided schema, then `query_ast` and `schema_ast` are objects describing the ASTs for the query and schema.",
      "name": "output",
      "type": "array\u003cobject[any: any], object[any: any]\u003e"
    }
  },
  "graphql.parse_and_verify": {
    "args": [
      {
        "name": "query",
        "type": "any\u003cstring, object[any: any]\u003e"
      },
      {
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "result": {
      "description": " `output` is of the form `[valid, query_ast, schema_ast]`. If the query is valid given the provided schema, then `valid` is `true`, and `query_ast` and `schema_ast` are objects describing the ASTs for the GraphQL query and schema. Otherwise, `valid` is `false` and `query_ast` and `schema_ast` are `{}`.",
      "name": "output",
      "type": "array\u003cboolean, object[any: any], object[any: any]\u003e"
    }
  },
  "graphql.parse_query": {
    "args": [
      {
        "name": "query",
        "type": "string"
      }
    ],
    "result": {
      "description": "AST object for the GraphQL query.",
      "name": "output",
      "type": "object[any: any]"
    }
  },
  "graphql.parse_schema": {
    "args": [
      {
        "name": "schema",
        "type": "string"
      }
    ],
    "result": {
      "description": "AST object for the GraphQL schema.",
      "name": "output",
      "type": "object[any: any]"
    }
  },
  "graphql.schema_is_valid": {
    "args": [
      {
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "result": {
      "description": "`true` if the schema is a valid GraphQL schema. `false` otherwise.",
      "name": "output",
      "type": "boolean"
    }
  },
  "gt": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "result": {
      "description": "true if `x` is greater than `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "gte": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "result": {
      "description": "true if `x` is greater or equal to `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "hex.decode": {
    "args": [
      {
        "description": "a hex-encoded string",
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "deseralized from `x`",
      "name": "y",
      "type": "string"
    }
  },
  "hex.encode": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "serialization of `x` using hex-encoding",
      "name": "y",
      "type": "string"
    }
  },
  "http.send": {
    "args": [
      {
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "result": {
      "name": "response",
      "type": "object[any: any]"
    }
  },
  "indexof": {
    "args": [
      {
        "description": "string to search in",
        "name": "haystack",
        "type": "string"
      },
      {
        "description": "substring to look for",
        "name": "needle",
        "type": "string"
      }
    ],
    "result": {
      "description": "index of first occurrence, `-1` if not found",
      "name": "output",
      "type": "number"
    }
  },
  "indexof_n": {
    "args": [
      {
        "description": "string to search in",
        "name": "haystack",
        "type": "string"
      },
      {
        "description": "substring to look for",
        "name": "needle",
        "type": "string"
      }
    ],
    "result": {
      "description": "all indices at which `needle` occurs in `haystack`, may be empty",
      "name": "output",
      "type": "array[number]"
    }
  },
  "internal.member_2": {
    "args": [
      {
        "type": "any"
      },
      {
        "type": "any"
      }
    ],
    "result": {
      "type": "boolean"
    }
  },
  "internal.member_3": {
    "args": [
      {
        "type": "any"
      },
      {
        "type": "any"
      },
      {
        "type": "any"
      }
    ],
    "result": {
      "type": "boolean"
    }
  },
  "internal.print": {
    "args": [
      {
        "type": "array[set[any]]"
      }
    ],
    "result": {}
  },
  "intersection": {
    "args": [
      {
        "description": "set of sets to intersect",
        "name": "xs",
        "type": "set[set[any]]"
      }
    ],
    "result": {
      "description": "the intersection of all `xs` sets",
      "name": "y",
      "type": "set[any]"
    }
  },
  "io.jwt.decode": {
    "args": [
      {
        "description": "JWT token to decode",
        "name": "jwt",
        "type": "string"
      }
    ],
    "result": {
      "description": "`[header, payload, sig]`, where `header` and `payload` are objects; `sig` is the hexadecimal representation of the signature on the token.",
      "name": "output",
      "type": "array\u003cobject[any: any], object[any: any], string\u003e"
    }
  },
  "io.jwt.decode_verify": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified and whose claims are to be checked",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "claim verification constraints",
        "name": "constraints",
        "type": "object[string: any]"
      }
    ],
    "result": {
      "description": "`[valid, header, payload]`:  if the input token is verified and meets the requirements of `constraints` then `valid` is `true`; `header` and `payload` are objects containing the JOSE header and the JWT claim set; otherwise, `valid` is `false`, `header` and `payload` are `{}`",
      "name": "output",
      "type": "array\u003cboolean, object[any: any], object[any: any]\u003e"
    }
  },
  "io.jwt.encode_sign": {
    "args": [
      {
        "description": "JWS Protected Header",
        "name": "headers",
        "type": "object[string: any]"
      },
      {
        "description": "JWS Payload",
        "name": "payload",
        "type": "object[string: any]"
      },
      {
        "description": "JSON Web Key (RFC7517)",
        "name": "key",
        "type": "object[string: any]"
      }
    ],
    "result": {
      "description": "signed JWT",
      "name": "output",
      "type": "string"
    }
  },
  "io.jwt.encode_sign_raw": {
    "args": [
      {
        "description": "JWS Protected Header",
        "name": "headers",
        "type": "string"
      },
      {
        "description": "JWS Payload",
        "name": "payload",
        "type": "string"
      },
      {
        "description": "JSON Web Key (RFC7517)",
        "name": "key",
        "type": "string"
      }
    ],
    "result": {
      "description": "signed JWT",
      "name": "output",
      "type": "string"
    }
  },
  "io.jwt.verify_es256": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_es384": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_es512": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_hs256": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "plain text secret used to verify the signature",
        "name": "secret",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_hs384": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "plain text secret used to verify the signature",
        "name": "secret",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_hs512": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "plain text secret used to verify the signature",
        "name": "secret",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_ps256": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_ps384": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_ps512": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_rs256": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_rs384": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_rs512": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_array": {
    "args": [
      {
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "`true` if `x` is an array, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_boolean": {
    "args": [
      {
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "`true` if `x` is an boolean, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_null": {
    "args": [
      {
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "`true` if `x` is null, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_number": {
    "args": [
      {
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "`true` if `x` is a number, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_object": {
    "args": [
      {
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "`true` if `x` is an object, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_set": {
    "args": [
      {
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "`true` if `x` is a set, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_string": {
    "args": [
      {
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "`true` if `x` is a string, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "json.filter": {
    "args": [
      {
        "name": "object",
        "type": "object[any: any]"
      },
      {
        "description": "JSON string paths",
        "name": "paths",
        "type": "any\u003carray[any\u003cstring, array[any]\u003e], set[any\u003cstring, array[any]\u003e]\u003e"
      }
    ],
    "result": {
      "description": "remaining data from `object` with only keys specified in `paths`",
      "name": "filtered",
      "type": "any"
    }
  },
  "json.is_valid": {
    "args": [
      {
        "description": "a JSON string",
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if `x` is valid JSON, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "json.marshal": {
    "args": [
      {
        "description": "the term to serialize",
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "the JSON string representation of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "json.match_schema": {
    "args": [
      {
        "description": "document to verify by schema",
        "name": "document",
        "type": "any\u003cstring, object[any: any]\u003e"
      },
      {
        "description": "schema to verify document by",
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "result": {
      "description": "`output` is of the form `[match, errors]`. If the document is valid given the schema, then `match` is `true`, and `errors` is an empty array. Otherwise, `match` is `false` and `errors` is an array of objects describing the error(s).",
      "name": "output",
      "type": "array\u003cboolean, array[object\u003cdesc: string, error: string, field: string, type: string\u003e]\u003e"
    }
  },
  "json.patch": {
    "args": [
      {
        "name": "object",
        "type": "any"
      },
      {
        "name": "patches",
        "type": "array[object\u003cop: string, path: any\u003e[any: any]]"
      }
    ],
    "result": {
      "description": "result obtained after consecutively applying all patch operations in `patches`",
      "name": "output",
      "type": "any"
    }
  },
  "json.remove": {
    "args": [
      {
        "name": "object",
        "type": "object[any: any]"
      },
      {
        "description": "JSON string paths",
        "name": "paths",
        "type": "any\u003carray[any\u003cstring, array[any]\u003e], set[any\u003cstring, array[any]\u003e]\u003e"
      }
    ],
    "result": {
      "description": "result of removing all keys specified in `paths`",
      "name": "output",
      "type": "any"
    }
  },
  "json.unmarshal": {
    "args": [
      {
        "description": "a JSON string",
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "the term deseralized from `x`",
      "name": "y",
      "type": "any"
    }
  },
  "json.verify_schema": {
    "args": [
      {
        "description": "the schema to verify",
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "result": {
      "description": "`output` is of the form `[valid, error]`. If the schema is valid, then `valid` is `true`, and `error` is `null`. Otherwise, `valid` is `false` and `error` is a string describing the error.",
      "name": "output",
      "type": "array\u003cboolean, any\u003cnull, string\u003e\u003e"
    }
  },
  "lower": {
    "args": [
      {
        "description": "string that is converted to lower-case",
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "lower-case of x",
      "name": "y",
      "type": "string"
    }
  },
  "lt": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "result": {
      "description": "true if `x` is less than `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "lte": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "result": {
      "description": "true if `x` is less than or equal to `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "max": {
    "args": [
      {
        "name": "collection",
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "result": {
      "description": "the maximum of all elements",
      "name": "n",
      "type": "any"
    }
  },
  "min": {
    "args": [
      {
        "name": "collection",
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "result": {
      "description": "the minimum of all elements",
      "name": "n",
      "type": "any"
    }
  },
  "minus": {
    "args": [
      {
        "name": "x",
        "type": "any\u003cnumber, set[any]\u003e"
      },
      {
        "name": "y",
        "type": "any\u003cnumber, set[any]\u003e"
      }
    ],
    "result": {
      "description": "the difference of `x` and `y`",
      "name": "z",
      "type": "any\u003cnumber, set[any]\u003e"
    }
  },
  "mul": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      }
    ],
    "result": {
      "description": "the product of `x` and `y`",
      "name": "z",
      "type": "number"
    }
  },
  "neq": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "result": {
      "description": "true if `x` is not equal to `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "net.cidr_contains": {
    "args": [
      {
        "name": "cidr",
        "type": "string"
      },
      {
        "name": "cidr_or_ip",
        "type": "string"
      }
    ],
    "result": {
      "name": "result",
      "type": "boolean"
    }
  },
  "net.cidr_contains_matches": {
    "args": [
      {
        "name": "cidrs",
        "type": "any\u003cstring, array[any\u003cstring, array[any]\u003e], object[string: any\u003cstring, array[any]\u003e], set[any\u003cstring, array[any]\u003e]\u003e"
      },
      {
        "name": "cidrs_or_ips",
        "type": "any\u003cstring, array[any\u003cstring, array[any]\u003e], object[string: any\u003cstring, array[any]\u003e], set[any\u003cstring, array[any]\u003e]\u003e"
      }
    ],
    "result": {
      "description": "tuples identifying matches where `cidrs_or_ips` are contained within `cidrs`",
      "name": "output",
      "type": "set[array\u003cany, any\u003e]"
    }
  },
  "net.cidr_expand": {
    "args": [
      {
        "name": "cidr",
        "type": "string"
      }
    ],
    "result": {
      "description": "set of IP addresses the CIDR `cidr` expands to",
      "name": "hosts",
      "type": "set[string]"
    }
  },
  "net.cidr_intersects": {
    "args": [
      {
        "name": "cidr1",
        "type": "string"
      },
      {
        "name": "cidr2",
        "type": "string"
      }
    ],
    "result": {
      "name": "result",
      "type": "boolean"
    }
  },
  "net.cidr_is_valid": {
    "args": [
      {
        "name": "cidr",
        "type": "string"
      }
    ],
    "result": {
      "name": "result",
      "type": "boolean"
    }
  },
  "net.cidr_merge": {
    "args": [
      {
        "description": "CIDRs or IP addresses",
        "name": "addrs",
        "type": "any\u003carray[any\u003cstring\u003e], set[string]\u003e"
      }
    ],
    "result": {
      "description": "smallest possible set of CIDRs obtained after merging the provided list of IP addresses and subnets in `addrs`",
      "name": "output",
      "type": "set[string]"
    }
  },
  "net.cidr_overlap": {
    "args": [
      {
        "type": "string"
      },
      {
        "type": "string"
      }
    ],
    "result": {
      "type": "boolean"
    }
  },
  "net.lookup_ip_addr": {
    "args": [
      {
        "description": "domain name to resolve",
        "name": "name",
        "type": "string"
      }
    ],
    "result": {
      "description": "IP addresses (v4 and v6) that `name` resolves to",
      "name": "addrs",
      "type": "set[string]"
    }
  },
  "numbers.range": {
    "args": [
      {
        "name": "a",
        "type": "number"
      },
      {
        "name": "b",
        "type": "number"
      }
    ],
    "result": {
      "description": "the range between `a` and `b`",
      "name": "range",
      "type": "array[number]"
    }
  },
  "object.filter": {
    "args": [
      {
        "description": "object to filter keys",
        "name": "object",
        "type": "object[any: any]"
      },
      {
        "name": "keys",
        "type": "any\u003carray[any], object[any: any], set[any]\u003e"
      }
    ],
    "result": {
      "description": "remaining data from `object` with only keys specified in `keys`",
      "name": "filtered",
      "type": "any"
    }
  },
  "object.get": {
    "args": [
      {
        "description": "object to get `key` from",
        "name": "object",
        "type": "object[any: any]"
      },
      {
        "description": "key to lookup in `object`",
        "name": "key",
        "type": "any"
      },
      {
        "description": "default to use when lookup fails",
        "name": "default",
        "type": "any"
      }
    ],
    "result": {
      "description": "`object[key]` if present, otherwise `default`",
      "name": "value",
      "type": "any"
    }
  },
  "object.keys": {
    "args": [
      {
        "description": "object to get keys from",
        "name": "object",
        "type": "object[any: any]"
      }
    ],
    "result": {
      "description": "set of `object`'s keys",
      "name": "value",
      "type": "set[any]"
    }
  },
  "object.remove": {
    "args": [
      {
        "description": "object to remove keys from",
        "name": "object",
        "type": "object[any: any]"
      },
      {
        "description": "keys to remove from x",
        "name": "keys",
        "type": "any\u003carray[any], object[any: any], set[any]\u003e"
      }
    ],
    "result": {
      "description": "result of removing the specified `keys` from `object`",
      "name": "output",
      "type": "any"
    }
  },
  "object.subset": {
    "args": [
      {
        "description": "object to test if sub is a subset of",
        "name": "super",
        "type": "any\u003carray[any], object[any: any], set[any]\u003e"
      },
      {
        "description": "object to test if super is a superset of",
        "name": "sub",
        "type": "any\u003carray[any], object[any: any], set[any]\u003e"
      }
    ],
    "result": {
      "description": "`true` if `sub` is a subset of `super`",
      "name": "result",
      "type": "any"
    }
  },
  "object.union": {
    "args": [
      {
        "name": "a",
        "type": "object[any: any]"
      },
      {
        "name": "b",
        "type": "object[any: any]"
      }
    ],
    "result": {
      "description": "a new object which is the result of an asymmetric recursive union of two objects where conflicts are resolved by choosing the key from the right-hand object `b`",
      "name": "output",
      "type": "any"
    }
  },
  "object.union_n": {
    "args": [
      {
        "name": "objects",
        "type": "array[object[any: any]]"
      }
    ],
    "result": {
      "description": "asymmetric recursive union of all objects in `objects`, merged from left to right, where conflicts are resolved by choosing the key from the right-hand object",
      "name": "output",
      "type": "any"
    }
  },
  "opa.runtime": {
    "args": [],
    "result": {
      "description": "includes a `config` key if OPA was started with a configuration file; an `env` key containing the environment variables that the OPA process was started with; includes `version` and `commit` keys containing the version and build commit of OPA.",
      "name": "output",
      "type": "object[string: any]"
    }
  },
  "or": {
    "args": [
      {
        "name": "x",
        "type": "set[any]"
      },
      {
        "name": "y",
        "type": "set[any]"
      }
    ],
    "result": {
      "description": "the union of `x` and `y`",
      "name": "z",
      "type": "set[any]"
    }
  },
  "plus": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      }
    ],
    "result": {
      "description": "the sum of `x` and `y`",
      "name": "z",
      "type": "number"
    }
  },
  "print": {
    "args": [],
    "result": {}
  },
  "product": {
    "args": [
      {
        "name": "collection",
        "type": "any\u003carray[number], set[number]\u003e"
      }
    ],
    "result": {
      "description": "the product of all elements",
      "name": "n",
      "type": "number"
    }
  },
  "providers.aws.sign_req": {
    "args": [
      {
        "name": "request",
        "type": "object[string: any]"
      },
      {
        "name": "aws_config",
        "type": "object[string: any]"
      },
      {
        "name": "time_ns",
        "type": "number"
      }
    ],
    "result": {
      "name": "signed_request",
      "type": "object[any: any]"
    }
  },
  "rand.intn": {
    "args": [
      {
        "name": "str",
        "type": "string"
      },
      {
        "name": "n",
        "type": "number"
      }
    ],
    "result": {
      "description": "random integer in the range `[0, abs(n))`",
      "name": "y",
      "type": "number"
    }
  },
  "re_match": {
    "args": [
      {
        "type": "string"
      },
      {
        "type": "string"
      }
    ],
    "result": {
      "type": "boolean"
    }
  },
  "regex.find_all_string_submatch_n": {
    "args": [
      {
        "description": "regular expression",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "string to match",
        "name": "value",
        "type": "string"
      },
      {
        "description": "number of matches to return; `-1` means all matches",
        "name": "number",
        "type": "number"
      }
    ],
    "result": {
      "name": "output",
      "type": "array[array[string]]"
    }
  },
  "regex.find_n": {
    "args": [
      {
        "description": "regular expression",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "string to match",
        "name": "value",
        "type": "string"
      },
      {
        "description": "number of matches to return, if `-1`, returns all matches",
        "name": "number",
        "type": "number"
      }
    ],
    "result": {
      "description": "collected matches",
      "name": "output",
      "type": "array[string]"
    }
  },
  "regex.globs_match": {
    "args": [
      {
        "name": "glob1",
        "type": "string"
      },
      {
        "name": "glob2",
        "type": "string"
      }
    ],
    "result": {
      "name": "result",
      "type": "boolean"
    }
  },
  "regex.is_valid": {
    "args": [
      {
        "description": "regular expression",
        "name": "pattern",
        "type": "string"
      }
    ],
    "result": {
      "name": "result",
      "type": "boolean"
    }
  },
  "regex.match": {
    "args": [
      {
        "description": "regular expression",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "value to match against `pattern`",
        "name": "value",
        "type": "string"
      }
    ],
    "result": {
      "name": "result",
      "type": "boolean"
    }
  },
  "regex.replace": {
    "args": [
      {
        "description": "string being processed",
        "name": "s",
        "type": "string"
      },
      {
        "description": "regex pattern to be applied",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "regex value",
        "name": "value",
        "type": "string"
      }
    ],
    "result": {
      "name": "output",
      "type": "string"
    }
  },
  "regex.split": {
    "args": [
      {
        "description": "regular expression",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "string to match",
        "name": "value",
        "type": "string"
      }
    ],
    "result": {
      "description": "the parts obtained by splitting `value`",
      "name": "output",
      "type": "array[string]"
    }
  },
  "regex.template_match": {
    "args": [
      {
        "description": "template expression containing `0..n` regular expressions",
        "name": "template",
        "type": "string"
      },
      {
        "description": "string to match",
        "name": "value",
        "type": "string"
      },
      {
        "description": "start delimiter of the regular expression in `template`",
        "name": "delimiter_start",
        "type": "string"
      },
      {
        "description": "end delimiter of the regular expression in `template`",
        "name": "delimiter_end",
        "type": "string"
      }
    ],
    "result": {
      "name": "result",
      "type": "boolean"
    }
  },
  "rego.metadata.chain": {
    "args": [],
    "result": {
      "description": "each array entry represents a node in the path ancestry (chain) of the active rule that also has declared annotations",
      "name": "chain",
      "type": "array[any]"
    }
  },
  "rego.metadata.rule": {
    "args": [],
    "result": {
      "description": "\"rule\" scope annotations for this rule; empty object if no annotations exist",
      "name": "output",
      "type": "any"
    }
  },
  "rego.parse_module": {
    "args": [
      {
        "description": "file name to attach to AST nodes' locations",
        "name": "filename",
        "type": "string"
      },
      {
        "description": "Rego module",
        "name": "rego",
        "type": "string"
      }
    ],
    "result": {
      "name": "output",
      "type": "object[string: any]"
    }
  },
  "rem": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      }
    ],
    "result": {
      "description": "the remainder",
      "name": "z",
      "type": "number"
    }
  },
  "replace": {
    "args": [
      {
        "description": "string being processed",
        "name": "x",
        "type": "string"
      },
      {
        "description": "substring to replace",
        "name": "old",
        "type": "string"
      },
      {
        "description": "string to replace `old` with",
        "name": "new",
        "type": "string"
      }
    ],
    "result": {
      "description": "string with replaced substrings",
      "name": "y",
      "type": "string"
    }
  },
  "round": {
    "args": [
      {
        "description": "the number to round",
        "name": "x",
        "type": "number"
      }
    ],
    "result": {
      "description": "the result of rounding `x`",
      "name": "y",
      "type": "number"
    }
  },
  "semver.compare": {
    "args": [
      {
        "name": "a",
        "type": "string"
      },
      {
        "name": "b",
        "type": "string"
      }
    ],
    "result": {
      "description": "`-1` if `a \u003c b`; `1` if `a \u003e b`; `0` if `a == b`",
      "name": "result",
      "type": "number"
    }
  },
  "semver.is_valid": {
    "args": [
      {
        "name": "vsn",
        "type": "any"
      }
    ],
    "result": {
      "description": "`true` if `vsn` is a valid SemVer; `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "set_diff": {
    "args": [
      {
        "type": "set[any]"
      },
      {
        "type": "set[any]"
      }
    ],
    "result": {
      "type": "set[any]"
    }
  },
  "sort": {
    "args": [
      {
        "description": "the array or set to be sorted",
        "name": "collection",
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "result": {
      "description": "the sorted array",
      "name": "n",
      "type": "array[any]"
    }
  },
  "split": {
    "args": [
      {
        "description": "string that is split",
        "name": "x",
        "type": "string"
      },
      {
        "description": "delimiter used for splitting",
        "name": "delimiter",
        "type": "string"
      }
    ],
    "result": {
      "description": "splitted parts",
      "name": "ys",
      "type": "array[string]"
    }
  },
  "sprintf": {
    "args": [
      {
        "description": "string with formatting verbs",
        "name": "format",
        "type": "string"
      },
      {
        "description": "arguments to format into formatting verbs",
        "name": "values",
        "type": "array[any]"
      }
    ],
    "result": {
      "description": "`format` formatted by the values in `values`",
      "name": "output",
      "type": "string"
    }
  },
  "startswith": {
    "args": [
      {
        "description": "search string",
        "name": "search",
        "type": "string"
      },
      {
        "description": "base string",
        "name": "base",
        "type": "string"
      }
    ],
    "result": {
      "description": "result of the prefix check",
      "name": "result",
      "type": "boolean"
    }
  },
  "strings.any_prefix_match": {
    "args": [
      {
        "description": "search string(s)",
        "name": "search",
        "type": "any\u003cstring, array[string], set[string]\u003e"
      },
      {
        "description": "base string(s)",
        "name": "base",
        "type": "any\u003cstring, array[string], set[string]\u003e"
      }
    ],
    "result": {
      "description": "result of the prefix check",
      "name": "result",
      "type": "boolean"
    }
  },
  "strings.any_suffix_match": {
    "args": [
      {
        "description": "search string(s)",
        "name": "search",
        "type": "any\u003cstring, array[string], set[string]\u003e"
      },
      {
        "description": "base string(s)",
        "name": "base",
        "type": "any\u003cstring, array[string], set[string]\u003e"
      }
    ],
    "result": {
      "description": "result of the suffix check",
      "name": "result",
      "type": "boolean"
    }
  },
  "strings.replace_n": {
    "args": [
      {
        "description": "replacement pairs",
        "name": "patterns",
        "type": "object[string: string]"
      },
      {
        "description": "string to replace substring matches in",
        "name": "value",
        "type": "string"
      }
    ],
    "result": {
      "name": "output",
      "type": "string"
    }
  },
  "strings.reverse": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "name": "y",
      "type": "string"
    }
  },
  "substring": {
    "args": [
      {
        "name": "value",
        "type": "string"
      },
      {
        "description": "offset, must be positive",
        "name": "offset",
        "type": "number"
      },
      {
        "description": "length of the substring starting from `offset`",
        "name": "length",
        "type": "number"
      }
    ],
    "result": {
      "description": "substring of `value` from `offset`, of length `length`",
      "name": "output",
      "type": "string"
    }
  },
  "sum": {
    "args": [
      {
        "name": "collection",
        "type": "any\u003carray[number], set[number]\u003e"
      }
    ],
    "result": {
      "description": "the sum of all elements",
      "name": "n",
      "type": "number"
    }
  },
  "time.add_date": {
    "args": [
      {
        "description": "nanoseconds since the epoch",
        "name": "ns",
        "type": "number"
      },
      {
        "name": "years",
        "type": "number"
      },
      {
        "name": "months",
        "type": "number"
      },
      {
        "name": "days",
        "type": "number"
      }
    ],
    "result": {
      "description": "nanoseconds since the epoch representing the input time, with years, months and days added",
      "name": "output",
      "type": "number"
    }
  },
  "time.clock": {
    "args": [
      {
        "description": "a number representing the nanoseconds since the epoch (UTC); or a two-element array of the nanoseconds, and a timezone string",
        "name": "x",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e\u003e"
      }
    ],
    "result": {
      "description": "the `hour`, `minute` (0-59), and `second` (0-59) representing the time of day for the nanoseconds since epoch in the supplied timezone (or UTC)",
      "name": "output",
      "type": "array\u003cnumber, number, number\u003e"
    }
  },
  "time.date": {
    "args": [
      {
        "description": "a number representing the nanoseconds since the epoch (UTC); or a two-element array of the nanoseconds, and a timezone string",
        "name": "x",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e\u003e"
      }
    ],
    "result": {
      "description": "an array of `year`, `month` (1-12), and `day` (1-31)",
      "name": "date",
      "type": "array\u003cnumber, number, number\u003e"
    }
  },
  "time.diff": {
    "args": [
      {
        "name": "ns1",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e\u003e"
      },
      {
        "name": "ns2",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e\u003e"
      }
    ],
    "result": {
      "description": "difference between `ns1` and `ns2` (in their supplied timezones, if supplied, or UTC) as array of numbers: `[years, months, days, hours, minutes, seconds]`",
      "name": "output",
      "type": "array\u003cnumber, number, number, number, number, number\u003e"
    }
  },
  "time.format": {
    "args": [
      {
        "description": "a number representing the nanoseconds since the epoch (UTC); or a two-element array of the nanoseconds, and a timezone string; or a three-element array of ns, timezone string and a layout string (see golang supported time formats)",
        "name": "x",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e, array\u003cnumber, string, string\u003e\u003e"
      }
    ],
    "result": {
      "description": "the formatted timestamp represented for the nanoseconds since the epoch in the supplied timezone (or UTC)",
      "name": "formatted timestamp",
      "type": "string"
    }
  },
  "time.now_ns": {
    "args": [],
    "result": {
      "description": "nanoseconds since epoch",
      "name": "now",
      "type": "number"
    }
  },
  "time.parse_duration_ns": {
    "args": [
      {
        "description": "a duration like \"3m\"; see the [Go `time` package documentation](https://golang.org/pkg/time/#ParseDuration) for more details",
        "name": "duration",
        "type": "string"
      }
    ],
    "result": {
      "description": "the `duration` in nanoseconds",
      "name": "ns",
      "type": "number"
    }
  },
  "time.parse_ns": {
    "args": [
      {
        "description": "format used for parsing, see the [Go `time` package documentation](https://golang.org/pkg/time/#Parse) for more details",
        "name": "layout",
        "type": "string"
      },
      {
        "description": "input to parse according to `layout`",
        "name": "value",
        "type": "string"
      }
    ],
    "result": {
      "description": "`value` in nanoseconds since epoch",
      "name": "ns",
      "type": "number"
    }
  },
  "time.parse_rfc3339_ns": {
    "args": [
      {
        "name": "value",
        "type": "string"
      }
    ],
    "result": {
      "description": "`value` in nanoseconds since epoch",
      "name": "ns",
      "type": "number"
    }
  },
  "time.weekday": {
    "args": [
      {
        "description": "a number representing the nanoseconds since the epoch (UTC); or a two-element array of the nanoseconds, and a timezone string",
        "name": "x",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e\u003e"
      }
    ],
    "result": {
      "description": "the weekday represented by `ns` nanoseconds since the epoch in the supplied timezone (or UTC)",
      "name": "day",
      "type": "string"
    }
  },
  "to_number": {
    "args": [
      {
        "name": "x",
        "type": "any\u003cnull, boolean, number, string\u003e"
      }
    ],
    "result": {
      "name": "num",
      "type": "number"
    }
  },
  "trace": {
    "args": [
      {
        "description": "the note to include",
        "name": "note",
        "type": "string"
      }
    ],
    "result": {
      "description": "always `true`",
      "name": "result",
      "type": "boolean"
    }
  },
  "trim": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      },
      {
        "description": "string of characters that are cut off",
        "name": "cutset",
        "type": "string"
      }
    ],
    "result": {
      "description": "string trimmed of `cutset` characters",
      "name": "output",
      "type": "string"
    }
  },
  "trim_left": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      },
      {
        "description": "string of characters that are cut off on the left",
        "name": "cutset",
        "type": "string"
      }
    ],
    "result": {
      "description": "string left-trimmed of `cutset` characters",
      "name": "output",
      "type": "string"
    }
  },
  "trim_prefix": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      },
      {
        "description": "prefix to cut off",
        "name": "prefix",
        "type": "string"
      }
    ],
    "result": {
      "description": "string with `prefix` cut off",
      "name": "output",
      "type": "string"
    }
  },
  "trim_right": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      },
      {
        "description": "string of characters that are cut off on the right",
        "name": "cutset",
        "type": "string"
      }
    ],
    "result": {
      "description": "string right-trimmed of `cutset` characters",
      "name": "output",
      "type": "string"
    }
  },
  "trim_space": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      }
    ],
    "result": {
      "description": "string leading and trailing white space cut off",
      "name": "output",
      "type": "string"
    }
  },
  "trim_suffix": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      },
      {
        "description": "suffix to cut off",
        "name": "suffix",
        "type": "string"
      }
    ],
    "result": {
      "description": "string with `suffix` cut off",
      "name": "output",
      "type": "string"
    }
  },
  "type_name": {
    "args": [
      {
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "one of \"null\", \"boolean\", \"number\", \"string\", \"array\", \"object\", \"set\"",
      "name": "type",
      "type": "string"
    }
  },
  "union": {
    "args": [
      {
        "description": "set of sets to merge",
        "name": "xs",
        "type": "set[set[any]]"
      }
    ],
    "result": {
      "description": "the union of all `xs` sets",
      "name": "y",
      "type": "set[any]"
    }
  },
  "units.parse": {
    "args": [
      {
        "description": "the unit to parse",
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "the parsed number",
      "name": "y",
      "type": "number"
    }
  },
  "units.parse_bytes": {
    "args": [
      {
        "description": "the byte unit to parse",
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "the parsed number",
      "name": "y",
      "type": "number"
    }
  },
  "upper": {
    "args": [
      {
        "description": "string that is converted to upper-case",
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "upper-case of x",
      "name": "y",
      "type": "string"
    }
  },
  "urlquery.decode": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "URL-encoding deserialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "urlquery.decode_object": {
    "args": [
      {
        "description": "the query string",
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "the resulting object",
      "name": "object",
      "type": "object[string: array[string]]"
    }
  },
  "urlquery.encode": {
    "args": [
      {
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "URL-encoding serialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "urlquery.encode_object": {
    "args": [
      {
        "name": "object",
        "type": "object[string: any\u003cstring, array[string], set[string]\u003e]"
      }
    ],
    "result": {
      "description": "the URL-encoded serialization of `object`",
      "name": "y",
      "type": "string"
    }
  },
  "uuid.rfc4122": {
    "args": [
      {
        "name": "k",
        "type": "string"
      }
    ],
    "result": {
      "description": "a version 4 UUID; for any given `k`, the output will be consistent throughout a query evaluation",
      "name": "output",
      "type": "string"
    }
  },
  "walk": {
    "args": [
      {
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "pairs of `path` and `value`: `path` is an array representing the pointer to `value` in `x`",
      "name": "output",
      "type": "array\u003carray[any], any\u003e"
    }
  },
  "yaml.is_valid": {
    "args": [
      {
        "description": "a YAML string",
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "`true` if `x` is valid YAML, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "yaml.marshal": {
    "args": [
      {
        "description": "the term to serialize",
        "name": "x",
        "type": "any"
      }
    ],
    "result": {
      "description": "the YAML string representation of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "yaml.unmarshal": {
    "args": [
      {
        "description": "a YAML string",
        "name": "x",
        "type": "string"
      }
    ],
    "result": {
      "description": "the term deseralized from `x`",
      "name": "y",
      "type": "any"
    }
  }
}
